x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: 基礎暗号学講座・第27回 〜RSA暗号に対する実装攻撃〜  ---

著者：IPUSIRON

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　久しぶりの暗号理論の記事です。ここ数年の間、錠前ばかり追いかけていたので、新鮮に感じます。色々忘れていることも多かったので、自分の忘備録ついでにWBの記事にしました。
　今回は、実装攻撃の概要とRSA暗号に対する攻撃例を紹介します。


■0x02.) 実装攻撃

　実装攻撃とは、アルゴリズムが実装されたソフトウェアやハードウェアを対象にした攻撃です。理論的に安全である暗号アルゴリズムであっても、それを利用するためにコンピュータに適切に実装しないと、実装方法や利用環境に依存した脆弱性が生まれることがあります。こうした実装攻撃を考慮した防衛技術を総称して耐タンパー技術といいます。また、耐タンパー性を持つデバイスのことを耐タンパーデバイスといいます。
　例えば、ICカードはICチップを内蔵されており、暗号処理ができるようになっています。本記事ではICカードのような暗号装置に対する実装攻撃や耐タンパー技術について解説します。


■0x03.) 守るべき情報

　暗号装置は様々な情報を保持しており、実装攻撃から守る必要があります。例えば、守るべき情報としては次が挙げられます。

・プライバシの高い個人情報
・秘密鍵
・機密情報
・価値の高い情報


■0x04.) 中見出し：実装攻撃者の分類

　攻撃者は実装攻撃を通じて、秘密情報（特に秘密鍵）を解読しようとします。攻撃者の能力は3つのレベルに分類できます。

○クラスⅠ
・対象のシステムに対して十分な知識を持っていないが、標準的な解析設備を利用できる攻撃者。	・例：技術系の学生

○クラスⅡ
・解読経験も持っており、高度な能力と高性能な設備を利用できる攻撃者。
・例：経験値が高い技術者・専門家

○クラスⅢ
・巨額の資金源に支えられており、洗練された解読を実現できる攻撃者。
・解読結果が費用を上回るのであれば、解読時間は数箇月から数年といった長期間にわたっても攻撃を行うことがある。
・例：専門家集団、国家組織、マフィアあるいはそのつながりを持つ技術者集団

　例えば、クレジットカードのような磁気カードは、スキマーと呼ばれるハードウェアによって情報を読み取ったり、複製したりできます。そのため、クラスⅠでも解読に成功します。
　一方、ICカードは、少なくともクラスⅠの攻撃者に耐性を持つように設計されます。加えて、耐タンパー技術により、クラスⅡ〜Ⅲの攻撃者に対しても耐えうるように設計されるのが望ましいといえます。


■0x05.) 実装攻撃の分類

　暗号アルゴリズムが実装されたモジュールに対して実装攻撃を行う際には、「入力」「出力」「モジュール内部」が攻撃対象となりえます。入力と出力は、モジュールから出ている正規のI/O（Input/Output）端子です。モジュール内部にアクセスするには、物理的・化学的・機械的な手段でモジュールを変形させます。
　また、入力に与える信号やエネルギーとしては正規のものと非正規のものがあります。例えば、サイドチャネル攻撃は、正規の処理中に漏洩する情報を解析します。

●破壊するか否かによる分類

○破壊型解析

　破壊型解析とは、暗号装置を破壊して実現する実装攻撃のことです。物理解析とも呼ばれます。もっとも原始的な手法ですが、非常に有効な解析といえます。例えば、次の解析手法が挙げられます。
・顕微鏡解析
・プローブ解析

　ICカードの場合は、ICチップを覆っている絶縁体を削り、その内側にある信号線などに直接アクセスして情報を取り出したり、回路を複製したりできます。こうした破戒型攻撃を成功に導くためには、ICチップの製造工程、回路設計、暗号化アルゴリズムについての知識が事前に必要といえます。一般に特殊な解析装置や解析技術が必要とされています。
　破壊型解析の後で再度ICモジュールを使うことができません。同種の暗号装置であれば、同様の回路構造を持つはずです。1つのデバイスは破壊型解析で秘密情報の抽出方法を解析し、他のデバイスは非破壊型解析を行うことで秘密情報を得ることができます。

○破壊型解析の耐タンパー技術

　破壊型解析の対策は、破壊の予防・対策に分けられます。破壊の予防は破壊しにくい素材で覆ったり、破壊する場所を隠したりします。ただし、こうした方法はクラスⅠの攻撃者に対しても時間稼ぎに過ぎません。
　そもそも攻撃者が破壊する目的は、内部回路のレイアウトを確認したり、配線にアクセスしたりするためです。そこで、規則的なレイアウトを止めたり、ダミーの配線を追加したりして、回路を解析しにくくします。特に、プリント基板設計ソフトなどは配線やモジュールの位置を最適化してくれるため、装置の開発者にとって非常に便利ですが、顕微鏡解析の観点からは望ましくない結果になる恐れがあります。また、ダミーの配線は見た目だけでなく、実際にダミーのデータを流すことでより効果的に攻撃者をだますことができます。
　破壊を検知したときにメモリに記録された情報を消去したり、書き換えたりすることも有効です。破壊を検知するためには、絶縁体の中に網状にセンサー回路を設置することで実現できます。チップ表面が空気に触れると記録内容が消滅するメモリチップや、信号を読み出すプローブを取り付けると動作できなくなる回路などもあります。
　他のアプローチとして、クロック信号を不規則にするという手法があります。プローブ解析によって、動作中の情報を読み取るときはクロック信号にもとづいてタイミングを合わせます。クロック信号が不規則であれば、こうした解析を妨害できることが期待できます。

○非破壊解析

　非破壊型解析とは、暗号装置を破壊しないで実現する実装攻撃のことです。例えば、次の解析手法が挙げられます。

・処理時間解析（タイミング解析）
・消費時間解析（電力解析解析）
・放射電磁解析（テンペスト解析）
・故障利用解析（フォールトベース解析）

　ICチップが暗号処理を行う際には、消費電力・処理時間・電磁波などの情報（サイドチャネル情報という）を外部から観測できます(*1)。ICカードはメモリ内に秘密鍵を保持していることがあります。秘密情報とサイドチャネル情報の関連性が高い場合、サイドチャネル情報から秘密情報（あるいはその部分情報）が漏れる恐れがあります。こうしたサイドチャネル情報に注目した攻撃をサイドチャネル解析といいます。
　理論的に提案された当初は、攻撃の実現性が疑問視されていました。しかし、現在では具体的な攻撃手法が提案されており、脅威として考えられます。

脚注
*1：それらの物理的な情報の伝送経路をサイドチャネルといいます。

●顕微鏡解析

　顕微鏡解析は、回路のパターンや配置を解析します。レイアウト解析とも呼ばれます。光学顕微鏡でICチップの内部を拡大して撮影して、見た目から構造を解析します。この段階では、CPU、コプロセッサ、メモリ、配線などの位置を調べて、次の解析の足掛かりとします。

●プローブ解析

　プローブ解析は、プローブ（探針）を用いて、メモリや配線の電位を調べたり、逆に電荷を与えたりして動作を解析します。プローブ解析を行うためには、顕微鏡解析でメモリや配線の位置を特定しておく必要があります。ICチップの設計・製造する現場では、設計通りに動作しないICチップをデバッグする際に、これと同様なことが行われています。
　回路パターンまで特定できないときは、暗号装置を動作させながらプローブ解析を行うことで、配線を追跡したり、攻撃ポイントを特定したりします。攻撃ポイントが特定できれば、暗号化アルゴリズムに相当する回路部の入出力のレジスタからビット情報を読み取れることがあります。

●処理時間解析

　アルゴリズムや回路は入力の差によって、出力が得られるまでの時間に差が生じます。差が生じる理由は、回路やアルゴリズム、キャッシュの有無などです。出力値が得られる時間差があることをうまく利用することで鍵を推定できます。処理時間解析（タイミング解析）は、「予想した鍵を用いた場合の処理時間」と「実際の処理時間」が等しいかどうかにより、鍵を推定する攻撃です。
　例えば、公開鍵暗号は復号時に秘密鍵が使用するため、復号にかかる処理時間が一定でない場合、処理時間解析により解読される恐れがあります。

●処理時間解析の対策

　鍵情報や入力データによって処理時間が平均化するように回路設計を行います。また、プロセス内の乱数を用いて復号処理に要する時間をランダム化する方法があります。この手法をブラインド化（blinding）といいます。OpenSSLには、ブラインド化を使ってタイミング攻撃を無効にするAPIが用意されています。

●電力解析

　回路の消費電力は、演算の種類や書き込むデータの値に関係して変動します。電力解析では、ICチップが消費する電力を外部からモニタリングして、そのときに処理した秘密情報を推定する攻撃です。
　電力解析は、次の2種類に大別されます。

・単純電力解析（SPA：Simple Power Analysis）
・差分電力解析（DPA：Differential Power Analysis）

　SPAは消費電力だけから秘密情報を推定する方法であり、統計的分析を行いません。一方、DPAは、積極的に統計的分析を用います。多くのデータを暗号装置に入力して、消費電力の値を集めます。次に、入力データをビット列で場合分けして、全データの平均値との差分を取り、秘密情報と相関のある消費電力の変化を探し出します。
　いずれに解析方法においても、暗号装置や測定機器から発生するノイズの存在を考慮しなければなりません。一般にこれらから発生するノイズは高周波成分を多く含んでいることが知られており、高周波をカットするフィルタが有効といえます。

○電力解析の対策
　電力解析の対策の基本は、消費電力を下げることです。さらに、意図的にノイズを発生させる回路を設けます。ノイズが大きい状態で、消費電力の差が小さくなれば、解析はより困難になるためです。
　他のアプローチとしては、攻撃者に暗号装置の内部データを容易に推測されないようにするために、データをランダム化するという手法もあります。

●放射電磁波解析

　放射電磁波解析は、暗号装置から発生する電磁波から秘密情報を推定する攻撃です。基本的な考え方は電力解析と同様です。

●故障利用解析

　故障利用解析とは、故意に誤作動を引き起こして処理結果を得て、正しい処理結果と比較することで、秘密情報を解析する攻撃です。誤作動を引き起こすために、次のようなアプローチが採用されます。これらの攻撃を総称してフォールト攻撃といいます。

・異常値の入力
・異常な電源供給
・規定外の周波数クロックの供給
・電磁照射
・ストロボフラッシュ
・レーザ照射

○故障利用攻撃の対策

　周波数・供給電圧・温度などのセンサーを搭載しておき、異常な状況を検知します。検知したら誤作動する前にシステムの動作を停止させます。こうすることで結果的に誤作動を引き起こすことを防止します。


■0x06.) RSA暗号に対する実装攻撃

　暗号装置にRSA暗号が実装されていたとき、採用しているアルゴリズムやハードウェアによって様々な実装攻撃が可能となります。ここでは代表例のみを紹介します。

●RSA暗号の復習

　RSA暗号については、WB34で解説しているので、参考にしてください。

http://wizardbible.org/34/34.txt

●べき乗剰余計算とバイナリ法

　暗号化アルゴリズムや復号アルゴリズムではべき乗剰余計算が登場します。べき乗剰余計算とは、a^x mod Nという計算です。これはRSA暗号に限らず、他の多くの公開鍵暗号でも同様です。
　a, x, Nはkビットとします。そして、3つのパラメータの合計ビット数をnとすると、n=3kになります。
　もっとも単純なアプローチは、最初にx-1回乗算してから、Nで割った余りを求めるという方法です。しかし、この方法ではx-1≒2^k=2^(n/3)=(2^(1/3))^n回の乗算が必要となり、入力サイズnの指数関数になっています。さらに、Nで割る前に巨大な数になってしまい、計算過程を保存するメモリ領域の観点からも非効率です。場合によっては、通常のコンピュータが扱えるサイズを超えてしまう恐れがあります。
　次のアプローチは、最後に剰余を計算するのではなく、乗算をしながらにこまめに剰余を計算するという方法です。a=c mod Nかつb=d mod Nならば、ab=cd mod Nであることはすでに見ました。「aをNで割った余りc」と「bをNで割った余りb」を掛けたcdは、Nで割った余りに等しくなることを意味します。この方法であれば、計算過程を保存するメモリ領域はそれほど気にする必要がありません。また、乗算で扱う数が小さいということは1回の乗算当たりの計算時間も効率化できています。しかしながら、乗算の回数は依然として入力サイズnの指数関数のままです。

○バイナリ法
　乗算の回数を改善化するために、高速べき乗剰余法と呼ばれるアルゴリズムが存在します。

入力：
・a：底
・x：指数
・N：法
出力：
・y：ax mod Nの計算結果

　アルゴリズムの動作は、以下の通りです。

1：xの2進表現を求めます。
　その結果、x={2^(k-1)}*{x_(k-1)}+{2^(k-2)}*{x_(k-2)}+…+2*x1+x0であったとします。ただし、xk-1=1です。
2：i=k-2とします。
3：y=aとします。
4：i≧0の間、次の処理を繰り返します。
　4a：y=y2 mod Nとします。
　4b：xi=1ならば、y=y×a mod Nとします。
　4c：i=i-1とします。
5：yを出力します。

　kビットの最大値はx=1…1bになります。このxに対してバイナリ法を適用すると、常にステップ4bを実行することになります。ステップ4bの乗算回数は2回であり、k-1回ループするので、合計の乗算回数は2(k-1)=2(n/3-1)=2n/3-2/3回になります。これはもっとも乗算回数が多い状況ですが、入力サイズnの多項式になっています。

○RSA暗号とバイナリ法

　RSA暗号の暗号化アルゴリズムではme mod Nを計算します。eは非常に大きいので、eを2進表現したとき1の個数は平均して約k/2程度といえます。よって、バイナリ法による計算時間は、平均してLen(e)に比例します(*1)。また、ステップ4aの「y=y2 mod N」、ステップ4bの「y=y×a mod N」は、両方ともAB mod Nの形の計算です。A, B, Nのビット長は大体kビットと考えられます。高速な乗算剰余計算を実現するモンゴメリ法を用いると、この計算時間はk2に比例することが知られています。よって、暗号化処理はk2*Len(e)に比例します（復号処理も同じ形なので、同様の議論ができる）。

脚注
*1：Len(・)は長さを返す関数です。

●プローブ解析による秘密情報の読み取り

　ここではコプロセッサ(*1)で乗算剰余計算AB mod N（A, B, Nはnビット）が行われており、高速べき乗剰余計算がバイナリ法で実装されているものとします。
　コプロセッサで乗算剰余計算が行われていれば、コプロセッサはA, B, Nのレジスタを持っており、これらのレジスタを使って「A←AB mod N」という処理が行われます。
　復号処理に注目します。なぜならば、公開鍵暗号では復号の際に秘密鍵を使用するからです。RSA暗号の復号アルゴリズムは、Dec(sk, c)=cd mod Nという動作をします。そのため、Nには公開鍵に含まれるRSAモジュール、Bにはcが格納されていると想定できます。また、乗算剰余の途中の演算結果は、随時Aに上書きされます。
　プローブ解析により、レジスタAの値を読み取り続けます。バイナリ法は指数のバイナリ表現した結果、0か1かにより動作が変わります。つまり、Aの値の変化を読み取ることで、dの情報が1ビットずつ判明します。
　しかしながら、プローブで同時に観察できる配線はせいぜい8本程度といわれています。しかも、1本はクロック信号を読み取るために用いられることが多いといえます。つまり、読み取れるビット数は7程度になります。その一方で、レジスタAはnビットであり、到底すべての配線をカバーできません。
　そこで攻撃者は未知の復号指数dが使われて復号されたときの7ビットを観測します。乗算剰余計算はLen(d)の比例回数分だけ実行され、その度に観測値が変化します。その変化を系列とすると、1ビットの7系列が得られたことになります。次に、推測した復号指数d'を使って、どうようにして7系列を得ます。後は両者の系列を比較します。もし、d=d'であれば、両者の系列は完全に一致するはずです。逆に、両者の系列が一致しても、必ずしもd=d'と言い切れませんが、その可能性は高いことが知られています。

脚注
*1：コプロセッサとは、CPUの補助するプロセッサのことです。一部の暗号装置はよく登場する計算用のコプロセッサを搭載して、高速化を図っています。例えば、乗算剰余計算や特定の暗号化・復号処理などでコプロセッサの力を借ります。

●故障利用解析によるRSA暗号の解読

　RSA暗号の復号アルゴリズムにおいて、中国人剰余定理を応用すると高速に計算できることが知られています。べき乗計算が約1/4で済むことが期待できます。
　アルゴリズムで計算される処理を抜粋すると、次の通りです。

c1=c mod p, c2=c mod q
a=p^(-1)  mod q
d1=d mod p-1, d2=d mod q-1
m1=c1^d1 mod p, m2=c2^d2 mod q
m={a(m2-m1) mod q}p+m1　←(1)

　フォールト攻撃により誤作動が起きて、m2の計算において正しくない値m2'になったとします。すると、平文の計算の結果が次のようになってしまいます。

m'={a(m2'-m1)  mod q}p+m1　←(2)

　(2)式の両辺から(1)式を引くと、次のようになります。

m''-m=[{a(m2'-m1) mod q}p+m1]-[{a(m2-m1) mod q}p+m1]={a(m2'-m2) mod q}p

　よって、GCD(m''-m, N)=pが計算できます。つまり、Nの素因数が求められたことになります。
　この故障利用解析では、正しい計算結果である(1)式と誤作動した計算結果である(2)式が必要でしたが、正しい計算結果を必要としない攻撃法も提案されています。


■0x07) 終わりに

　この記事を書くにあたり、いくつかの文献を参考にしました。特に、以下の書籍は、お勧めです。前半では暗号理論について、後半では実装攻撃についてかなり詳しく言及しています。

『情報セキュリティの理論と技術—暗号理論からICカードの耐タンパー技術まで』（森北出版株式会社）
https://www.amazon.co.jp/dp/4627829515

