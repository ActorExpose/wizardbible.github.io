x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: マニアックJavaプログラミング第11回: 〜 しぶといアプリに仕上げよう 〜 ---

著者：金床

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　今回は、主にサーバーアプリやウェブアプリのように、長時間安定した稼働を期待される
アプリケーションを作る際のテクニックをいくつか紹介する。どれも特に技術的に高度な
ものではないが、読者の発想の転換や視点の変更に一役買うことができれば本望
である。


■0x02.) TCP接続のエラーを許容する

　プロキシサーバーなどを作る場合、SocketクラスやSSLSocketクラスを使って新
しいTCP接続を生成するという処理がひっきりなしに発生する。アクセスの多いサ
ーバーであれば数分で万単位、一日では百万単位の接続処理が行われることもあ
る。

　ご存じの通りインターネットというのはそれほど安定したネットワークではな
いので、パケットの損失などはちっとも珍しくない。数万回も接続処理を繰り返
すと、特にサーバーが落ちているわけではないのに、クライアント側からの接続
が失敗するということが起こる。もちろんOSカーネル内部のTCPスタックが、少し
のパケット損失ならば（SYN再送などで）カバーしてくれるのだが、それでもダメ
な場合にアプリケーション層に失敗が通知される。

　このような場合に処理をすぐにあきらめてエラーとしてしまうのではなく、も
う一回（あるいはさらに数回）接続を試みさせてみるという考え方がある。これ
は以下のようなコードで実現できる。

-----
public static Socket connect( String host, int port, int connectTimeOut )
throws IOException
{
IOException ex = null;
Socket socket = null;
SocketAddress sockAddr = new InetSocketAddress( host, port );
for( int i = 0; i < 3; ++i )
	{
	try
		{
		socket = new Socket();
		socket.connect( sockAddr, connectTimeOut );
		return socket;
		}
	catch( IOException e )
		{
		ex = e;
		}
	}
throw ex;
}
-----

　この関数は最大で3回ほど接続を試してみるコードとなっている。3回のconnect
がすべて失敗したときには例外が送出される。

　connectはブロッキング処理となる。サーバー側の反応が悪いときには、関数が
戻るまでに時間が数秒から数十秒かかることもある。ここでは接続を3回試すため、
この待ち時間も通常の3倍になってしまう。そのため短くしたい場合には3番目の
引数であるconnectTimeOutを適切な値に設定するとよいだろう。

　ウェブブラウザの多くはこれに似た考え方のもとに実装されている。一度接続
が失敗しただけではエラーとせず、数回接続を試みるものが多い。

　また、上の関数では接続の失敗をログに記録していないが、後でどの程度の接
続が失敗しているのかを確認したい場合には、catchブロック内にロギングのコー
ドを入れておくとよいだろう。


■0x03.) DBにしぶとく接続する

　RDBMSに接続するアプリケーションにも前項と同じ考え方が適用できる（ちなみ
にコネクションプールを使う場合は何度も接続を繰り返す必要はないのだが、コ
ネクションプールにはそれとは別に色々と問題があったりするのでここでは触れ
ない）。

　DBとデータをやりとりする度に新規にConnectionオブジェクトを生成するよう
なコーディングをしている場合を考える。この場合、前項で説明したのと同じ理
由で、ごくまれに接続が失敗することがある。たいていの場合はTCPの接続の失敗
が原因となり、JDBCドライバ内から例外として送出される。このような場合、以
下のようなコードを書いておくとたまに起こるエラーをカバーすることができる。

-----
public static Connection getConnection( String dbmsUrl, String dbmsUser, String dbmsPass )
throws SQLException
{
Connection conn = null;
int count = 0;
while( true )
	{
	try
		{
		conn = DriverManager.getConnection( dbmsUrl, dbmsUser, dbmsPass );
		executeQuery( conn, "select count(*) from pg_user" );
		return conn;
		}
	catch( SQLException e )
		{
		++count;
		if( conn != null )
			{
			closeConnection( conn );
			}
		if( count == 3 )
			{
			throw e;
			}
		}
	}
}
-----

　（「2009年になってこんな原始的なコードを…」というツッコミは却下する。
このような部分は、別にイマドキの新しい記述にしなくても、動けばよいのであ
る。というかむしろ1.6系や1.7系のJREに変なバグがある場合に1.4系のJREでも動
かせるように、下位互換性を確保したいのである。）

　上記のコードは単一のDBサーバーに対する接続においてのエラーをカバーする
ものだ。最近では高性能なサーバーの価格が下落しつつ、かつパーツ等の信頼性
は昔と変わらず低いという現状がある。そのため複数の物理的なサーバーを用意
し、システム全体の冗長性を上げるというアプローチが採られる場面が増えてい
る。

　筆者もいくつかのシステムで、PostgreSQLとpgpool IIを組み合わせたマルチマ
スタのレプリケーション構成を使用している。このときPostgreSQLのダウンはpg
poolがカバーしてくれるのだが、pgpool自体が落ちたらどうするの？という問題
がある。そこで複数のサーバーでpgpoolを起動しておき、アプリケーションは1つ
めのpgpoolに接続できなかったら次のpgpoolに接続する…という動きをさせる。
これによってpgpoolのダウンすらもカバーすることができる。

　つまり、アプリケーションの設定ファイルには、以下のように接続先のDBサー
バー（実態はpgpool）として複数のDBMSのURLを記述しておく。ここではカンマ区
切りで記述している。

-----
dbmsUrl=jdbc:postgresql://192.168.1.1:9999/kntk,jdbc:postgresql://192.168.1.2:9999/kntk,jdbc:postgresql://192.168.1.3:9999/kntk
-----

　アプリケーションは1つめへの接続に失敗したら2つめに、それでもダメなら3つ
めに…としぶとく動作する。これによりハードウェア障害などによってpgpoolや
PostgreSQLを載せたサーバーがダウンしていてもシステム全体は稼働し続けるこ
とができるのだ。

　ちなみにpgpool IIは複数同時稼働を想定されていないため、オンラインリカバ
リ時には1つのインスタンスを残して他を落としておく必要がある（上のようなア
プリケーションの作りにしておけば、1つのインスタンスだけ残っていればシステ
ム全体は動作を続けることができる）。


■0x04.) エラーを分類し許容する

　アプリケーションがしぶとく動作を続けるためには、多少のエラーにはびくつ
かないようにする必要がある。

　まず、どのようなエラーが発生しうるかを事前にできるだけ想像しておく。0x
02項で紹介した「TCPの接続がたまに失敗する」などは典型的なものだ。他には例
えば「DBに接続できない」「DBが途中から反応しない」「ディスク容量が足りな
い等の理由でファイルが保存できない」「メモリが足りない」「ファイルディス
クリプタが足りない」「負荷が高すぎる」「ぬるぽ」「やる気がしない」「眠い」
などが考えられる。

　次に、これらのエラーのうち、どれをどこまで許容するかを考える。DBに接続
できなかったらそこでおしまいなのか？ファイルが保存できなかったらそこであ
きらめるのか？

　安西先生…　コーディングが…　したいです…

　えーと、何の話だっけ。ということでどのエラーをどこまで許可する（あるい
は、あきらめてアプリケーションを終了する）かを決定する。また同時に、これ
らのエラーが発生したことを（または、発生していないことを）を把握するため
に、ログファイルに記録したり、外部からエラーの発生状況をリアルタイムで取
得するためのインターフェースを用意したりする。


■0x05.) 機能を分類する

　0x04項と内容がかぶる部分があるが、アプリケーションが持つ機能のうち、重
要なものとそうでないものを分ける。そして、重要でない部分でエラーが発生し
た場合には、その影響がアプリケーション全体に及ばないようにする。

　例えばJRobinなどを使って、アクセス状況を5分ごとに画像ファイルとして出力
する機能をもったプロキシサーバーがあるとする。このプロキシサーバーの核と
なる機能は、いうまでもなくネットワークアプリケーションとしての動作だ。ア
プリケーションの作者にとって、グラフを描く機能は追加的なものにすぎない。

　しかし実際に実行されるコード（ライブラリ内部など、作者が自身で書いてい
ない部分）の量としては、ネットワークの部分よりもグラフの部分の方が多くな
ることも充分考えられる。そのため、充分に枯れているライブラリならばよいが、
グラフを描く部分でNullPointerException等の例外が発生する可能性も考えるよ
うにする。そして、グラフの描画処理が何度もエラーを出したりする場合には、
それを検知し、以降グラフを描かずに、核となるプロキシサーバーの機能に専念
するようにアプリケーションを作っておく。このようにすることで、万が一の場
合にもサービス断という事態を避けることができるかもしれない。

　また、アプリケーションが充分に枯れた後に、新しい機能を追加する場合につ
いても同様である。新しいコードにはバグが潜んでいる可能性が高いので、そこ
で発生したエラーがアプリケーション全体に及ばないようにしておく。充分なテ
スト期間が過ぎたら、より適切なエラー処理へと変更する。

　さらに別のアプローチとして、アプリケーションを分けてしまうというアプロ
ーチもある。djbによるqmailなどに代表される考え方だ。アプリケーション全体
を、シンプルな機能を持つ複数のプロセスに分ける。そしてプロセス間通信によ
ってサービス全体が実現されるようにする。あるプロセスが死んでしまった場合
などでも、サービス全体には影響を及ぼさないようにする。前述の例で言えば、
グラフを描くアプリケーションは独立させ、cronなどから呼び出してもよいだろ
う。


■0x06.) おしまい

　今回は、筆者の長いJava開発の経験に基づくひとつのアプローチを紹介した。
TCP接続やDB接続の失敗を許容するコードでは、再試行の前にsleepするのもよい
かもしれない。例えば最大で30秒間のDBサーバーのダウンを許容するような作り
にしておけば、何かの設定変更などでDBサーバーを再起動したい！というような
ケースに対応することができる。アプリケーションを開発する時点で、サーバー
管理や運用も含めたイメージを持っておくことで、このような冗長性が高く扱い
やすいアプリケーションを作成することができる。



