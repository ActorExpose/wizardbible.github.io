x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: 基礎暗号学講座・第26回 〜Schnorr認証法〜 ---

著者：IPUSIRON

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) ゼロ知識認証とは

　認証に対する攻撃は受動的攻撃と能動的攻撃に大別できる。
　ここで、認証を受ける側をP(Prover)、認証を行う側をV(Verifier)とする。

　受動的攻撃はPとVでの認証のやり取りを敵が盗聴する（学習段階）。その後、敵はPになりすまして、認証をパスしようとする攻撃である（なりすまし段階）。

　能動的攻撃はシーケンシャル攻撃とパラレル攻撃がある。
　シーケンシャル攻撃では、敵がVになりすまして、Pと何回かやり取りを行う（学習段階）。その後、敵はPになりすまして、認証をパスしようとする（なりすまし段階）。
　シーケンシャル攻撃では、学習段階で集めた情報を使って、なりすましを試みる。一方、パラレル攻撃では、学習段階となりすまし段階を随時実行できる。つまり、任意のタイミングで学習段階となりすまし段階を切り替えることができるのである。
　そのため、パラレル攻撃の方がシーケンシャル攻撃よりも強い攻撃となる。

　パスワード認証は、上記で定義した能動的攻撃だけでなく受動的攻撃に対しても脆弱である。
　受動的攻撃に対する対策としては、ワンタイムパスワード認証やチャレンジレスポンス認証がある。
　一方、能動的攻撃に対する対策としては、ワンタイムパスワード認証やチャレンジレスポンス認証では十分ではない。

　能動的攻撃に対しても安全であるためには、認証のやり取りからPだけが知っている秘密sが漏れてはいけない。
　つまり、認証のやり取りにおいて、Pだけが知っている秘密sをVに提示するのではなく、「sを秘密にしたまま、sを知っていることだけ」をVに証明できればよい。このような認証法をゼロ知識認証と呼ぶ。
　ゼロ知識認証であれば、受動的攻撃に対してだけでなく、能動的攻撃に対しても安全であるため、理想的な認証法であると期待できる（安全性の観点からは理想的かもしれないが、効率性や運用の観点からは理想的とは言い切れない）。


■0x02.) Schnorr認証法

　ゼロ知識認証にも多数の認証法が存在するが、今回はSchnorr認証法について解説する。"Schnorr"は「シュノア」と読む。

　Schnorr認証法は次のように動作する。

●初期化段階

　信頼できるセンターが大きな素数p、位数が大きな素数q、Z_p^*の要素gを公開する。

　証明者PはZ_qからsをランダムに選び、秘密鍵とする。
　次に、v=g^(-s) mod pを計算して、vを公開鍵としてセンターに登録する。

　以上より、センターの公開鍵は(p,q,g)、秘密鍵はsk=s、公開鍵はpk=vとなる。

●認証プロトコル

1：証明者PはZ_qからランダムにrを選び、x=g^r mod pを計算して、xを検証者Vに送信する（コミット）。

2：検証者VはZ_qからランダムにcを選び、証明者Pに送信する（チャレンジ）。

3：証明者Pはy=r+sc mod qを計算して、yを検証者Vに送信する（レスポンス）。


　なお、初期化段階の「g^q≡1 mod q」を満たすqの生成方法はWB41を参照せよ。


■0x03.) Schnorr認証法の性質

　まず上記に記載したSchnorr認証法が以下の3つの性質を持つことを直観的に示す。

・完全性
・健全性
・ゼロ知識性

●完全性

　完全性を示すためには、「秘密sを知っているアルゴリズムAは検証に受理できること」を示せばよい。

g^y・v^c mod p
=g^(r+sc)・g^(-sc) mod p
=g^r mod p
=x

　つまり、AはSchnorr認証法の証明者と同じ手順通りに（honestに）動作を行えば、100%検証が受理(accept)される。

●健全性

　健全性を示すためには、「検証を合格するアルゴリズムA~は秘密sを知っていること」を示せばよい。

　sを知らなければ、yがわからない。yがわからなければ、検証が受理(accept)されるのは、偶然以外ではありえない。

●ゼロ知識性

　ゼロ知識性を示すためには、「手順通りに実行しても、秘密sに関する知識は検証者Vに漏れないこと」を示せばよい。

　rはPだけが知っているので、Vはy=r+scからsを特定することはできない。
　また、「x=g^y・v^c mod p=g^y・g^(sc)・v^c mod p」のうち、Vにとって既知な情報はx,g^y,v^c,pであり、g^(sc)は未知である。そのため、ここからもsは漏れない。

　よって、敵が検証者になりすましても、敵はsを知ることができない。つまり、受動的攻撃には耐えられそうである。これを0x05で定理化して、証明する。

　なお、実はチャレンジの範囲が広いために、能動的攻撃に耐えるためには、離散対数問題よりも強い仮定が必要である。


■0x04.) Schnorr認証法の安全性

　Schnorr認証法は、離散対数問題が困難という仮定のもとで、受動的攻撃に対して安全であることを示す。そのためには、以下の定理を示せば、十分である。

[定理]確率τで受動的攻撃に成功する確率的多項式時間アルゴリズムA~が存在すると仮定すると、確率τ^s(1-1/q)以上で離散対数問題を解く確率的多項式時間アルゴリズムMが存在する。

[方針]A~の存在を利用して、Mを構成する。

[直観的な証明]Mの入力はv=g^(-s)を満たす(p,g,v)である。
-sが離散対数であるため、Mは最終的に-sと一致する値を出力できれば、証明が完成したことになる。

MはZ_qからランダムにy',c'を選択し、g^y'・v^c' mod pを計算し、その計算結果をx'とする。

これはMはP'とV'の間で学習段階をシミュレートしていることに対応する。ただし、手順通りの作り方と順番が異なる（ここでズルしている）。

(x',c',y')をトランスクリプトとして、学習段階のA~に与える。
すると、A~は攻撃段階を実行し始める。

攻撃段階のA~の相手である検証者をMはシミュレートしてあげる。この検証者をV'とする。
A~はV'に対してxを送信するので（コミット）、V'はZ_qからランダムにc1を選択して、A~に返す（チャレンジ）。
すると、A~はV'にy1を送信する（レスポンス）。
このy1は確率τで検証に合格する値になっている。

MはA'を巻き戻し、再びチャレンジをA~に送信する。
このときのチャレンジはZ_qからランダムにc2を選択したものとする。
すると、A~はV'にy2を送信する（レスポンス）。
このy2も確率τで検証に合格する値になっている。

MはA~の力を利用して、同じxに対して、2通りの答えを得た。
c1,c2間には以下が成り立っている。
x≡g^y・v^c1 mod p≡g^y・v^c2 mod p　←(*)

Mは(y1-y2)/(c2-c1) mod pを計算して、出力する。

これでMの構成は終わりである。

Mが出力した値が、離散対数-sと一致していることは、(*)を展開するとわかる。

次に、Mが離散対数を解く確率がτ^s(1-1/q)以上であることを示す。

c1=c2であると、y1=y2になってしまう。この確率は1/qである。つまり、1-1/qの確率でc1≠c2となる。
後は、A~が2回連続で受動的攻撃に成功するにはτ^2である。

よって、Mが離散対数を解く確率がτ^s(1-1/q)以上である。　□


■0x05.) ゼロ知識証明からデジタル署名へ

　受動的攻撃に対して安全なゼロ知識証明プロトコルに、ハッシュ関数を組み合わせると、（ランダムオラクルモデルにおいて）選択メッセージ攻撃に対して安全なデジタル署名を構成できることが知られている。
　これをFS（Fiat-Shamir）変換と呼ぶ。

　FS変換は次の通りである。

　まず、ゼロ知識証明プロトコルにおけるコミットメントをx、チャレンジをc、レスポンスをyとする。
　このとき、FS変換では、メッセージをmとするとc=H(m,x)を計算し、mに対する署名をσ=(c,y')とする（ただし、y'はcを用いてレスポンスを生成）。つまり、署名者は検証者にm,σ=(c,y')を送信する。

　ゼロ知識証明では検証者のチャレンジcは乱数であるが、FS変換ではメッセージとコミットメントを入力したときのハッシュ値を用いる。
　自分が知っているメッセージmでハッシュ値を作っても、自分でそのハッシュ値はコントロールできない。つまり、入出力の相互変換がなくなるため、デジタル署名に使えるのである。

　それでは、具体的にSchnorr認証法に対してFS変換を行ってみる。便宜上、FS変換後のデジタル署名はSchnorrデジタル署名と呼ぶことにする。

　パブリックな情報を(p,q,g)とする。Schnorr認証法の公開鍵はv=g^(-s) mod p、秘密鍵はsとする。
　また、ハッシュ関数をHとする。

　このときSchnorrデジタル署名の3つのアルゴリズムは次のようになる。

●鍵生成アルゴリズム：KeyGen

　1^kを入力とする。
　vk=v、sk=sとし、検証鍵としてvk、署名鍵としてskを出力する。

●署名アルゴリズム：Sign

　sk、メッセージmを入力とする。

1：Z_qからrをランダムに選択し、x=g^r mod pを計算する。

2：c=H(m,x)を計算する。

3：y=r+sc mod qを計算する。

4：メッセージm、署名σ=(c,y)を出力する。

●検証アルゴリズム：Vrfy

　(m,σ)、vkを入力とする。

1：x=g^y・v^c mod pを計算する。

2：c=H(m,x)が成り立てばacceptし、成り立たなければrejectする。

　離散対数問題が困難であるという仮定のもとで、このSchnorr署名は選択メッセージ攻撃に対して安全である。


■0x06.) 対話的ゼロ知識証明から非対話的ゼロ知識証明へ

　Schnorr認証法では証明者と検証者の間で、コミット・チャレンジ・レスポンスの通信、即ち3回の通信を行う。このように証明者と検証者で複数回やり取りを行うことを「対話的」と呼ぶ。
　実際のネットワークの通信の場合、通信の度にヘッダが付与されるため、対話の回数は少ない方が効率がよい。（効率だけの観点から見ると）、通信のやり取りは3回よりも2回、2回よりも1回の方がよい。そこで、証明者と検証者の間の通信が1回だけのゼロ知識証明は構成できるのかが問題になる。
　実はすでに紹介済みのFS変換と同様の考え方を用いると、任意の対話的ゼロ知識証明を非対話ゼロ知識証明を構成することができるのである。

　（ゼロ知識証明からデジタル署名に変換する）FS変換では署名者が検証者にm,(c,y')を送信するが、非対話を構成するための変換では証明者が検証者に(x,y')を送信すればよい。


■0x07.) 終わりに

　今回はゼロ知識認証の例としてSchnorr認証法を解説した。他にもよく知られたゼロ知識認証法として、GQ認証法やFFS認証法などがある。興味のある方はこれらのキーワードで検索してもらいたい。
